<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>모던 자바스크립트 Deep dive | Jooeun&#39;s TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="shortcut icon" href="/TIL/assets/favicon/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/TIL/assets/favicon/favicon.ico" type="image/x-icon">
    <meta name="description" content="Slow but Steadily. 오늘 배운 것들을 로그 형식으로 작성합니다. 개발 이야기를 주로 합니다.">
    <meta name="google-site-verification" content="m78_O9WTZXf9ieiRNO1Sfj4yMmeAVjyBlp4g4wVo988">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.221b52b8.css" as="style"><link rel="preload" href="/TIL/assets/js/app.8ff465dc.js" as="script"><link rel="preload" href="/TIL/assets/js/2.00df1cb1.js" as="script"><link rel="preload" href="/TIL/assets/js/28.c536056c.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.f5b9cba7.js"><link rel="prefetch" href="/TIL/assets/js/11.4c7b0cd8.js"><link rel="prefetch" href="/TIL/assets/js/12.dddb7be1.js"><link rel="prefetch" href="/TIL/assets/js/13.6e13bfa1.js"><link rel="prefetch" href="/TIL/assets/js/14.e77815df.js"><link rel="prefetch" href="/TIL/assets/js/15.6efa33fb.js"><link rel="prefetch" href="/TIL/assets/js/16.6ab0cfbf.js"><link rel="prefetch" href="/TIL/assets/js/17.8df57293.js"><link rel="prefetch" href="/TIL/assets/js/18.7210e956.js"><link rel="prefetch" href="/TIL/assets/js/19.7adf71a3.js"><link rel="prefetch" href="/TIL/assets/js/20.25a8bfa8.js"><link rel="prefetch" href="/TIL/assets/js/21.bcf37877.js"><link rel="prefetch" href="/TIL/assets/js/22.36199d76.js"><link rel="prefetch" href="/TIL/assets/js/23.f1cd1dc8.js"><link rel="prefetch" href="/TIL/assets/js/24.756006bb.js"><link rel="prefetch" href="/TIL/assets/js/25.40554c42.js"><link rel="prefetch" href="/TIL/assets/js/26.58b31cab.js"><link rel="prefetch" href="/TIL/assets/js/27.88a8736e.js"><link rel="prefetch" href="/TIL/assets/js/29.cc083ae4.js"><link rel="prefetch" href="/TIL/assets/js/3.c9dc6043.js"><link rel="prefetch" href="/TIL/assets/js/30.c645af51.js"><link rel="prefetch" href="/TIL/assets/js/31.39b31e20.js"><link rel="prefetch" href="/TIL/assets/js/32.2da0fa71.js"><link rel="prefetch" href="/TIL/assets/js/4.48c761ed.js"><link rel="prefetch" href="/TIL/assets/js/5.c3fe6d20.js"><link rel="prefetch" href="/TIL/assets/js/6.ba540a82.js"><link rel="prefetch" href="/TIL/assets/js/7.e3766bbe.js"><link rel="prefetch" href="/TIL/assets/js/8.ed398e50.js"><link rel="prefetch" href="/TIL/assets/js/9.ad5556f1.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.221b52b8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Jooeun's TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/joogle-ay" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.linkedin.com/in/jooeun-kang-845a49250" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Linked In
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/joogle-ay" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.linkedin.com/in/jooeun-kang-845a49250" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Linked In
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>2025 TIL</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/2025/2024-회고.html" class="sidebar-link">2023-2024 돌아보기</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2024 TIL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2023 TIL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2022 TIL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Bookmark</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="모던-자바스크립트-deep-dive"><a href="#모던-자바스크립트-deep-dive" class="header-anchor">#</a> 모던 자바스크립트 Deep dive</h1> <div class="custom-block tip"><p class="custom-block-title">ref</p> <p><strong>모던 자바스크립트 Deep dive (이웅모 저 / 위키북스)</strong><br>
상기 서적을 읽은 뒤 나름의 방식대로 요약 정리한 내용입니다.<br>
담당 챕터가 아닌 부분은 읽으며 기억해두고 싶은 부분만 발췌 메모해두었습니다.</p></div> <h2 id="_1장-프로그래밍"><a href="#_1장-프로그래밍" class="header-anchor">#</a> 1장. 프로그래밍</h2> <p>프로그래밍이란 문제(=요구사항)를 해결하기 위해 컴퓨터에게 프로그램의 실행을 요구하는 일종의 커뮤니케이션이다. 컴퓨터가 사고하는 방식은 인간과 다르게 직관이나 직감이 존재하지 않기 때문에 우리 머릿속에 있는 의도를 배제하고 정확하고 상세하게 요구사항을 설명할 줄 알아야 한다.<br>
이러한 사고 과정에서 필요한 것이 비로 <code>Computational thinking(컴퓨팅 사고)</code>이다.</p> <p>이 단계에서 분명히 알고 넘어가야 하는 것은 <strong>컴퓨터와 사람의 사고, 인지의 방식이 다르다는 것이다.</strong> 따라서 프로그래밍을 하기 위해서는 컴퓨터의 관점에서 문제를 사고해야 한다. 여기에는 논리적 수학적 사고가 필요하며, 해결 과제를 작은 단위로 분해하고 패턴화해서 추출해야하고, 프로그래밍 내에서 사용될 모든 개념은 평가 가능하도록 정의되어야 한다.</p> <ul><li><strong><code>기계어(Machine code)</code></strong> : 컴퓨터가 이해할 수 있는 언어.
<ul><li>기계어는 비트 단위로 기술되어있어 사람이 직접 작성하여 명령을 전달하기 힘들다.</li></ul></li> <li><strong><code>프로그래밍 언어(Programming language)</code></strong> : 사람이 이해할 수 있는 약속된 구문으로 구성된 언어.
<ul><li>프로그래밍 언어로 명령을 작성한 후, 일종의 번역기에 해당하는 컴파일러(Compiler)나 인터프리터(Interpreter)를 이용해 기계어로 변환할 수 있다.</li></ul></li></ul> <p>프로그래밍이란 이러한 프로그래밍 언어를 사용해 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. 이 프로그래밍 언어는 <code>구문(syntax)</code>과 <code>의미(semantics)</code>의 조합으로 표현된다.</p> <div class="language-text extra-class"><pre class="language-text"><code>언어의 의미는 문맥에 있는 것이지 문법에 있는 것이 아니다. -노엄 촘스키
</code></pre></div><p>문법에 부합하는 것은 물론이고 <strong>수행하고자 하는 바를 정확한 의미로 수행하는 프로그래밍 언어가 비로소 의미가 있다.</strong> 물론 이러한 문제 해결을 적절하게 수행하기 위해서는 문법의 이해가 필수적이다. 적절한 자료구조와 함수의 흐름을 제어해 요구사항의 집합을 해결하는 것이 프로그래밍의 목적이라고 볼 수 있다.</p> <h2 id="_2장-자바스크립트란"><a href="#_2장-자바스크립트란" class="header-anchor">#</a> 2장. 자바스크립트란?</h2> <h4 id="ecmascript"><a href="#ecmascript" class="header-anchor">#</a> ECMAScript</h4> <p>넷스케이프 커뮤니케이션즈에서 비영리 표준화 기구인 ECMA 인터내셔널에 자바스크립트의 표준화를 요청해 만든 표준화 사양. 2015년에 공개된 ECMAScript 6(ECMAScript 2015, ES6)는 let/const 키워드, 화살표 함수, 클래스, 모듈 등과 같이 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입하는 큰 변화가 있었다. ES6 이후의 ECMAScript 들은 보통 연도를 붙여서 부른다. (ECMA 2020 등..)</p> <p>ECMAScript는 JS의 뼈대가 되는 표준 사양으로, 자바스크립트는 이러한 ECMAScript와 브러우저가 별도 지원하는 클라이언트 사이드 Web API로 이루어져 있다.</p> <ul><li>클라이언트 사이드 Web API란?
<ul><li>DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등</li> <li>ECMAScript와는 별도로 월드 와이드 웹 콘소시엄(World Wide Web Consortium, W3C)에서 별도의 사양으로 관리하고 있다.</li></ul></li></ul> <h4 id="자바스크립트-성장의-역사"><a href="#자바스크립트-성장의-역사" class="header-anchor">#</a> 자바스크립트 성장의 역사</h4> <p>Ajax -&gt; jQuery -&gt; V8 자바스크립트 엔진 -&gt; Node.js -&gt; SPA 프레임워크</p> <h4 id="자바스크립트의-특징"><a href="#자바스크립트의-특징" class="header-anchor">#</a> 자바스크립트의 특징</h4> <ul><li>인터프리터 언어</li> <li>웹 브라우저에서 동작하는 유일한 프로그래밍 언어</li> <li>명령형(Imperative), 함수형(Functional), 프로토타입 기반(Prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어</li></ul> <h2 id="_4장-변수"><a href="#_4장-변수" class="header-anchor">#</a> 4장. 변수</h2> <h4 id="변수란-무엇인가"><a href="#변수란-무엇인가" class="header-anchor">#</a> 변수란 무엇인가?</h4> <p>애플리케이션이 다루는 데이터는 컴퓨터에 저장되고 연산에 이용된다. 컴퓨터는 <strong>CPU를 이용하여 연산을 수행</strong>하고, <strong>메모리를 사용해 데이터를 기억(=저장)</strong> 한다.<br>
이 때, 데이터를 저장할 수 있는 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. 메모리 셀 하나는 1바이트의 크기를 가지고 있으며 고유의 메모리 주소를 가지고 있다.<br>
하지만 자바스크립트와 같은 언매니지드 언어는 <strong>안전상의 이유로 개발자가 메모리에 직접 접근하는 것을 허용하지 않으며,</strong> 따라서 이미 메모리 셀을 차지하고 있는 데이터를 다시 끌어 와 사용하기 위해서는 <strong>해당 공간을 식별하기 위한 별도의 이름</strong> 을 붙여줘야 한다. 이러한 식별자를 <code>변수</code>라고 한다.</p> <p>간단하게 요약해보자면 다음과 같다.</p> <ul><li><strong><code>변수</code></strong>: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li> <li><strong><code>식별자</code></strong>: 어떠한 값을 구별해서 식별할 수 있는 고유한 이름으로, 변수 이름은 식별자의 일종이다.</li></ul> <p>변수 뿐 아니라 함수, 클래스 등의 이름은 모두 식별자에 해당한다.</p> <h4 id="변수의-선언과-할당"><a href="#변수의-선언과-할당" class="header-anchor">#</a> 변수의 선언과 할당</h4> <p>변수를 사용하기 위해서는 <strong><code>선언(declaration)</code></strong> 과 <strong><code>할당(assignment)</code></strong> 이라는 두 단계를 거쳐야 한다.</p> <ul><li><strong>변수 선언</strong> <ul><li>변수를 생성하는 것</li> <li>값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결하는 것</li> <li>변수를 선언하면 확보한 메모리 공간의 값을 초기화하여 undefined로 만든다.</li> <li>변수 선언을 위해 var, let, const 키워드를 사용할 수 있다.</li></ul></li> <li><strong>변수 할당</strong> <ul><li>해당 변수에 값을 할당한다.</li> <li>할당 연산자 = 를 이용하여 변수에 값을 할당할 수 있다.</li></ul></li></ul> <p>이 때 주의할 점이 있는데, 변수의 선언과 할당이 하나의 문으로 이루어져 있어도 자바스크립트는 이것을 선언과 할당으로 분리하여 각각 실행한다는 것이다. 그리고 변수의 선언과 할당은 서로 다른 시점에 실행된다.<br> <code>변수의 선언은 런타임 이전 소스코드의 평가 단계</code>에서 먼저 이루어진다. 그리고 <code>실제 소스코드가 순차적으로 실행되는 시점(=런타임)에 할당</code>이 이루어진다.<br>
변수의 선언이 런타임 이전에 끌어올려져 먼저 실행되는 것을 <strong><code>호이스팅</code></strong> 이라 하며, 호이스팅은 자바스크립트가 가지고 있는 고유한 특징 중 하나이다.</p> <h4 id="값의-재할당과-가비지-콜렉터"><a href="#값의-재할당과-가비지-콜렉터" class="header-anchor">#</a> 값의 재할당과 가비지 콜렉터</h4> <p>변수는 재할당을 이용해 값을 변경할 수 있다.<br>
이 때 값을 변경할 수 없는, 즉 고정된 값을 가지는 식별자는 변수가 아니라 상수(constant)라고 한다.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> score<span class="token punctuation">;</span>
score <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>
score <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span>
</code></pre></div><p>위와 같은 자바스크립트 코드를 실행하면, score라는 변수에 90이라는 값이 재할당되며 이전에 할당되었던 초기값 undefined와 80은 더 이상 아무런 식별자와도 연결되어있지 않는 값이 된다. 즉, <strong>아무도 사용하고 있지 않은 상태</strong> 가 되는 것이다. 이러한 불필요한 값들은 <code>가비지 콜렉터(Garbage collector)</code>에 의해 <strong>메모리에서 자동 해제</strong> 된다.</p> <div class="custom-block tip"><p class="custom-block-title">가비지 콜렉터란?</p> <p>애플리케이션이 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능이다. 여기서 더이상 사용되지 않는 메모리란 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있으며, 가비지 콜렉터를 통해 메모리 누수(Memory leak)를 방지한다.</p></div> <div class="custom-block tip"><p class="custom-block-title">매니지드 언어와 언매니지드 언어</p> <p>프로그래밍 언어는 메모리 관리 방식에 따라 매니지드 언어와 언매니지드 언어로 분류할 수 있다.</p> <p>📌 <strong>언매니지드 언어</strong>: 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 저수준 메모리 제어 기능을 이용할 수 있는 언어. 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만, 반대로 개발자의 역량에 따라 치명적인 오류를 생산할 가능성도 있다. 대표적인 예시는 C언어.</p> <p>📌 <strong>매니지드 언어</strong>: 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하는 언어. 개발자의 직접적인 메모리 제어를 허용하지 않는다. 매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느 정도 일정한 생산성을 확보할 수 있다는 장점이 있다, 하지만 성능 면에서 어느 정도의 손실은 감수할 수 밖에 없음.</p></div> <h4 id="식별자-네이밍-규칙"><a href="#식별자-네이밍-규칙" class="header-anchor">#</a> 식별자 네이밍 규칙</h4> <p>자바스크립트의 식별자 네이밍에는 다음과 같은 규칙이 있다.</p> <ul><li>식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러기호($)를 포함할 수 있다.</li> <li>단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.</li> <li>예약어는 식별자로 사용할 수 없다.</li> <li>자바스크립트의 예약어는 다음과 같아.</li></ul> <div class="language-text extra-class"><pre class="language-text"><code>await, break, case, catch, class, const ,continue, debugger, default, delete, do, else, enum, export, extends, false, finally, for, function, if, implements, import, in, instanceof, interface, let, new, null, package, private, protected, public, return, super, static, switch, this, throw, true, try, typeof, var, void, while, with, yield
</code></pre></div><p>식별자 이름을 정할 때에는 일정한 네이밍 컨벤션을 가지고 명명하는 것이 좋다. 보편적으로 사용되는 네이밍 컨벤션에는 다음과 같은 것들이 있다.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 카멜 케이스 (camelCase)</span>
<span class="token keyword">let</span> firstName<span class="token punctuation">;</span>

<span class="token comment">// 스네이크 케이스 (snake_case)</span>
<span class="token keyword">let</span> first_name<span class="token punctuation">;</span>

<span class="token comment">// 파스칼 케이스 (PascalCase)</span>
<span class="token keyword">let</span> FirstName<span class="token punctuation">;</span>

<span class="token comment">// 헝가리안 케이스 (typeHungarianCase)</span>
<span class="token keyword">let</span> strFirstName<span class="token punctuation">;</span> <span class="token comment">// type + identifier</span>
<span class="token keyword">let</span> $elem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;myId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// DOM 노드</span>
<span class="token keyword">let</span> observable$ <span class="token operator">=</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>document<span class="token punctuation">,</span> <span class="token string">&quot;click&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RxJS 옵저버블</span>
</code></pre></div><p>일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 상관없으나, 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜케이스를, 생성자 함수나 클래스의 이름에는 파스칼 케이스를 사용한다.</p> <h2 id="_10장-객체-리터럴"><a href="#_10장-객체-리터럴" class="header-anchor">#</a> 10장. 객체 리터럴</h2> <h4 id="객체란"><a href="#객체란" class="header-anchor">#</a> 객체란?</h4> <p>자바스크립트를 구성하는 <strong><code>거의 모든 것</code></strong> 이 객체이다. 원시값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체라고 볼 수 있다.</p> <ul><li><strong>원시 타입</strong>: 단 하나의 값</li> <li><strong>객체 타입</strong>: 다양한 타입의 값을 하나의 단위로 구성한 <strong>복합적인 자료 구조</strong></li></ul> <p><strong><em>📌 Point! 그렇다면 함수는?</em></strong><br>
자바스크립트의 함수는 <strong><code>일급 객체</code></strong> 이므로 값을 취급할 수 있다. 즉, 함수도 객체의 프로퍼티 값으로 사용할 수 있다는 뜻. 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 <strong><code>메서드(mothod)</code></strong> 라고 부른다.</p> <p>객체는 프로퍼티와 메서드로 구성된 집합체다.</p> <ul><li><strong>프로퍼티</strong>: 객체의 상태를 나타내는 값, data.</li> <li><strong>메서드</strong>: 프로퍼티를 참조하고 조작할 수 있는 동작, behavior</li></ul> <p>객체는 <strong>객체의 상태를 나타내는 값</strong>과 <strong>프로퍼티를 참조하고 조작할 수 있는 동작</strong>을 모두 포함할 수 있다. 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하며, 이러한 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 <strong><code>객체지향 프로그래밍</code></strong> 이라 한다.</p> <h4 id="객체-리터럴"><a href="#객체-리터럴" class="header-anchor">#</a> 객체 리터럴</h4> <p><strong>프로토타입 기반 객체지향 언어</strong>인 자바스크립트는 다양한 객체 생성 방법을 지원한다.</p> <ul><li>객체 리터럴</li> <li>Object 생성자 함수</li> <li>생성자 함수</li> <li>Object.create 메서드</li> <li>클래스 (ES6 이후)</li></ul> <p>이러한 방법 중 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다. <code>객체 리터럴이란 약속된 기호를 사용하여 객체를 생성하기 위한 표기법</code>으로, 중괄호 안에 0개 이상의 프로퍼티를 정의하는 형식으로 객체를 생성할 수 있다.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 객체 리터럴 예시</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Lee&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayHello</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;Lee&quot;, sayHello: ƒ }</span>

<span class="token comment">// 중괄호 내에 프로퍼티를 정의하지 않다고 빈 객체가 생성된다.</span>
<span class="token keyword">const</span> empty <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">주의!</p> <p>객체 리터럴의 중괄호는 코드 블록을 의미하지 않기 때문에 닫는 중괄호 뒤에 세미콜론을 붙여주어야 한다. 객체 리터럴은 값으로 평가되는 표현식이라는 점에 유의.</p></div> <p>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식으로, 객체를 생성하기 위해 클래스를 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다. 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성하는 시점에 프로퍼티를 만들어 줄 수도 있고, 객체를 생성한 이후 프로퍼티를 동적으로 추가할 수도 있다.</p> <h4 id="프로퍼티"><a href="#프로퍼티" class="header-anchor">#</a> 프로퍼티</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Lee&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 프로퍼티 키는 name, 프로퍼티 값은 &quot;Lee&quot;</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token comment">// 프로퍼티 키는 age, 프로퍼티 값은 20</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>객체에 담겨있는 데이터 하나하나가 프로퍼티이며, 프로퍼티는 쉼표(,)로 구분된다. 각각의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성되어 있다.<br>
프로퍼티 키와 값으로 사용할 수 있는 값은 다음과 같다.</p> <ul><li><strong>프로퍼티 키</strong>: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값</li> <li><strong>프로퍼티 값</strong>: 자바스크립트에서 사용할 수 있는 모든 값</li></ul> <p><strong>주의점</strong></p> <ol><li><a href="/TIL/book-js/js-deepdive.html#식별자-네이밍-규칙">식별자 네이밍 규칙</a>을 준수하지 않는 식별자도 키로 사용할 수 있다.</li> <li>프로퍼티 키는 문자열이므로 따옴표로 묶어야 한다. 단, 식별자 네이밍 규칙을 준수하는 경우에는 따옴표를 생략할 수 있다.</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 식별자 네이밍 규칙 준수 여부에 따른 차이 예시</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">&quot;Joo-eun&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 식별자 네이밍 규칙을 준수하는 키</span>
  <span class="token string-property property">&quot;last-name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Kang&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 식별자 네이밍 규칙을 준수하지 않는 키</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li>빈 문자열을 프로퍼티 키로 사용하는 것도 가능하나 키로서의 의미를 갖지 못하므로 권장하지 않는다.</li> <li>var, function 등의 예약어도 프로퍼티 키로 사용이 가능하나, 예상치 못한 에러가 발생할 수 있으므로 권장하지 않는다.</li> <li>이미 존재하는 프로퍼티 키를 중복 선언시 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 이 때 에러는 발생하지 않는다.</li></ol> <h4 id="메서드"><a href="#메서드" class="header-anchor">#</a> 메서드</h4> <p>프로퍼티 값이 함수인 경우 일반 함수와 구분하기 위하여 메서드라 부른다. 즉, <strong>메서드란 객체에 묶여 있는 함수이다.</strong> 이 때, this 키워드를 이용해 객체 자신을 참조할 수 있다. (자세한 내용은 22장 this에서 살펴볼 것)</p> <h4 id="프로퍼티-접근-방법-두-가지"><a href="#프로퍼티-접근-방법-두-가지" class="header-anchor">#</a> 프로퍼티 접근 방법 두 가지</h4> <p>프로퍼티에는 다음 두 가지 방법을 이용하여 접근할 수 있다.</p> <ul><li><p><strong>마침표 표기법</strong></p> <ul><li>마침표 프로퍼티 접근 연산자를 사용</li> <li>프로퍼티 키가 식별자 네이밍 규칙을 준수하는 경우에만 사용이 가능하다.</li></ul></li> <li><p><strong>대괄호 표기법</strong></p> <ul><li>대괄호 프로퍼티 접근 연산자를 사용</li> <li>프로퍼티 키가 식별자 네이밍 규칙을 준수하는 경우, 준수하지 않는 경우 모두 사용이 가능하다.</li> <li>대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. (따옴표로 감싸지 않은 이름을 입력하는 경우, 해당 식별자를 찾을 수 없어서 ReferenceError가 뜬다.)</li></ul></li> <li><p><strong>예시</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string-property property">'last-name'</span><span class="token operator">:</span> <span class="token string">'Lee'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token string">'last-name'</span><span class="token punctuation">;</span> <span class="token comment">// SyntaxError: Unexpected string</span>
person<span class="token punctuation">.</span>last<span class="token operator">-</span>name<span class="token punctuation">;</span> <span class="token comment">// 브라우저 환경 -&gt; NaN, Node,js 환경 -&gt; ReferenceError: last is not defined</span>
person<span class="token punctuation">[</span>last<span class="token operator">-</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// RefereceError: last is not defined</span>
person<span class="token punctuation">[</span><span class="token string">'last-name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Lee</span>
</code></pre></div><p>단, 프로퍼티 키가 숫자로 이루어진 문자열일 경우 따옴표를 생략할 수 있다.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string-property property">'last-name'</span><span class="token operator">:</span> <span class="token string">'Lee'</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

person<span class="token punctuation">[</span>last<span class="token operator">-</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// RefereceError: last is not defined</span>
person<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
</code></pre></div></li></ul> <h4 id="객체-리터럴의-기타-확장-기능"><a href="#객체-리터럴의-기타-확장-기능" class="header-anchor">#</a> 객체 리터럴의 기타 확장 기능</h4> <ol><li><strong>프로퍼티 값 갱신</strong> <ul><li>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.</li></ul></li> <li><strong>프로퍼티 동적 생성</strong> <ul><li>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.</li></ul></li> <li><strong>프로퍼티 삭</strong>제
<ul><li>delete 연산자를 이용해 객체의 프로퍼티를 삭제할 수 있다.</li></ul></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Lee&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 프로퍼티 값 갱신</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Kim&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;Kim&quot;}</span>

<span class="token comment">// 프로퍼티 동적 생성</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;Kim&quot;, age: 20}</span>

<span class="token comment">// 프로퍼티 삭제</span>
<span class="token keyword">delete</span> person<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;Kim&quot;}</span>

<span class="token comment">// 프로퍼티 삭제 - 객체 내에 해당 프로퍼티가 존재하지 않는 경우</span>
<span class="token keyword">delete</span> person<span class="token punctuation">.</span>address<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{name: &quot;Kim&quot;}</span>
<span class="token comment">// delete 연산자를 이용하여 해당 프로퍼티를 삭제할 수 없으므로 person이라는 객체가 가지고 있는 데이터는 동일하다. 단, 이때 에러는 발생하지 않는다.</span>
</code></pre></div><h4 id="es6에서-추가된-객체-리터럴-확장-기능"><a href="#es6에서-추가된-객체-리터럴-확장-기능" class="header-anchor">#</a> ES6에서 추가된 객체 리터럴 확장 기능</h4> <ol><li><strong>프로퍼티 축약 표현 (Property shorthand)</strong> <ul><li>프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때 키를 생략할 수 있다. ES6부터 제공하는 객체 리터럴의 확장 기능</li></ul></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
  y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {x: 1, y: 2}</span>
</code></pre></div><ol start="2"><li><strong>메서드 축약 표현</strong> <ul><li>메서드를 정의할 때 function 키워드를 생략하고 축약해서 표현할 수 있다.</li></ul></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Lee&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayHi</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hi!&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 위와 같은 표기 방식을 아래와 같이 축약할 수 있다.</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Lee&quot;</span><span class="token punctuation">,</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hi!&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li><strong>계산된 프로퍼티 이름</strong> <ul><li>문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 이용해 프로퍼티 키를 동적으로 생성할 수도 있다.</li></ul></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prefix<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token operator">++</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token operator">:</span> i<span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prefix<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token operator">++</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token operator">:</span> i<span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prefix<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token operator">++</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token operator">:</span> i<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {prop-1: 1, prop-2: 2, prop-3: 3}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">덧붙임</p> <p>이 부분 예시의 표기 방식이 신기했다.<br>
[ <code>++i</code> =&gt; <code>i = i + 1</code>과 같음 ] 이라는 사실을 이용해서 마치 반복문처럼 i를 계속해서 증가시키고, 해당 내용을 프로퍼티의 키와 값에 할당하는 방식..</p></div> <h2 id="_11장-원시-값과-객체의-비교"><a href="#_11장-원시-값과-객체의-비교" class="header-anchor">#</a> 11장. 원시 값과 객체의 비교</h2> <h4 id="원시-값"><a href="#원시-값" class="header-anchor">#</a> 원시 값</h4> <ol><li>불변성(immutability)<br>
원시 값은 변경 불가능한 값이다. 변수 값을 변경해도 원시 값 자체가 변경되는 것이 아니라 새로운 메모리 공간에 원시 값을 할당하고 해당 변수와 연결해주는 것 뿐이다. 이러한 값의 특성을 불변성이라고 한다.<br>
불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.</li> <li>문자열<br>
문자열은 길이에 따라 서로 다른 메모리 공간을 차지한다. 그래서 C나 자바 등에서는 문자열을 독립된 각 문자의 배열이나 String 객체 같은 형태로 처리하는데, 자바스크립트는 원시 타입인 문자열 타입을 제공한다. (자바스크립트의 장점!)<br> <strong>자바스크립트의 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.</strong></li></ol> <div class="custom-block tip"><p class="custom-block-title">이터러블</p> <p>그래서 이터러블이 뭔데? 32장 '이터러블'에서 알아보자.</p></div> <div class="custom-block tip"><p class="custom-block-title">유사배열객체</p> <p>마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체. 원시 값을 객체처럼 사용하는 경우 원시 값을 감싸는 래퍼 객체로 자동 변환된다. (이것도 차후에 살펴볼 내용이라고 함)</p></div> <h4 id="객체"><a href="#객체" class="header-anchor">#</a> 객체</h4> <ol><li><strong>객체 관리 방식</strong><br>
자바, C++같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스에 없는 프로퍼티나 메서드를 객체(인스턴스)에 추가할 수 없다. 하지만 자바스크립트는 객체 생성 이후에도 동적으로 프로퍼티와 메서드를 추가할 수 있고, 이건 사용하기 편리하지만 생성과 프로퍼티 접근에 비용이 많이 들어가는 비효율적 방식이다. 때문에 V8 JS 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 <strong>히든 클래스(Hidden class)</strong> 라는 방식을 사용해 프로퍼티 접근 시의 향상된 성능을 보장한다.</li> <li><strong>변경 가능한 값 (mutable value)</strong><br>
참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체이다. 변수는 이 참조 값을 통해 객체에 접근할 수 있다. 때문에 객체를 할당한 변수의 경우 &quot;변수는 객체를 참조하고 있다&quot; 또는 &quot;변수는 객체를 가리키고 있다&quot;라고 표현한다.<br>
이 때 객체는 변경 가능한 값이므로, 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. (프로퍼티 동적 추가, 갱신, 삭제 모두 가능하다는 뜻)<br>
-&gt; 단, 이러한 구조 때문에 부작용이 발생한다. 바로 원시 값과는 다르게 <strong>여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것.</strong></li></ol> <h4 id="값에-의한-전달-참조에-의한-전달"><a href="#값에-의한-전달-참조에-의한-전달" class="header-anchor">#</a> 값에 의한 전달 &amp; 참조에 의한 전달</h4> <ol><li><strong>값에 의한 전달 <code>pass by value</code></strong></li></ol> <ul><li>원시 값을 갖는 변수를 다른 변수에 할당하는 경우</li> <li>해당 원시 값이 복사되어 전달된다.</li> <li>복사한 값과 복사된 값은 같은 값이지만, 서로 다른 메모리 공간에 저장된 별개의 값이다.</li></ul> <ol start="2"><li><strong>참조에 의한 전달 <code>pass by reference</code></strong></li></ol> <ul><li>객체를 가리키는 변수를 다른 변수에 할당하는 경우</li> <li>원본의 참조 값이 복사되어 전달된다.</li> <li>복사한 값과 복사된 값이 동일한 참조 값을 가지게 된다. 즉, 두 개의 식별자가 하나의 객체를 공유하는 것. 원본과 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받게 된다.</li> <li>엄밀하게 말하면, 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사한다는 점에서 값에 의한 전달에 해당한다. 해당 값이 원시 값이 아니라 참조 값이라는 차이가 있을 뿐이다. 그렇기 때문에 '참조에 의한 전달'이 아니라 '공유에 의한 전달'이라고 표현할 수도 있다.</li></ul> <div class="custom-block tip"><p class="custom-block-title">덧붙임</p> <p>위와 같은 부분은 ECMAScript 사양에 정의된 JS 공식 용어는 아니다. 다만 여타 프로그래밍 언어에서 사용하는 언어를 가져와 표현하고 있을 뿐으로, 자바스크립트에는 포인터(pointer)가 존재하지 않기 때문에 포인터가 존재하는 다른 프로그래밍 언어의 '참조에 의한 전달'과 의미가 정확하게 일치하지 않는다.</p></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/TIL/assets/js/app.8ff465dc.js" defer></script><script src="/TIL/assets/js/2.00df1cb1.js" defer></script><script src="/TIL/assets/js/28.c536056c.js" defer></script>
  </body>
</html>
